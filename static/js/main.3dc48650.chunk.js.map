{"version":3,"sources":["hooks/useInterval.ts","state/slimeLocationsState.ts","state/slimeLocationsBoundingBoxState.ts","state/mapViewBoxState.ts","state/potentialNextSlimeLocationsState.ts","state/slimeLocationState.ts","components/SlimeLocation.tsx","components/Map.tsx","App.tsx","reportWebVitals.js","index.js"],"names":["useInterval","callback","delay","savedCallback","useRef","useEffect","current","id","setInterval","clearInterval","slimeLocationsState","atom","key","default","x","y","slimeLocationsBoundingBoxState","selector","get","slimeLocations","slimeXs","_","map","slimeYs","minX","min","maxX","max","minY","maxY","mapViewBoxState","serializeLocation","parseLocation","serialized","stringCoordinates","split","parseInt","potentialNextSlimeLocationsState","serializedSlimeLocations","Set","serializedPotentialNextSlimeLocations","potentiallyAddNextSlimeLocation","location","serializedLocation","has","add","each","effectiveOccupiedLocationsCount","length","sortBy","Array","from","effectiveMinX","effectiveMaxX","effectiveMinY","effectiveWidth","effectiveHeight","densityDifferenceFromTarget","boundsRatioDifferenceFromTarget","DEFAULT_SLIME_LOCATION","slimeLocationState","selectorFamily","find","slimeLocation","SlimeLocation","useRecoilValue","className","width","height","Map","potentialNextSlimeLocations","mapViewport","createLocation","setSlimeLocationsState","useSetRecoilState","useCreateLocation","update","useCallback","sample","slice","Math","ceil","viewBox","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3dc48650.chunk.js","sourcesContent":["import { useEffect, useRef } from \"react\";\n\nfunction useInterval(callback: () => void, delay: number | null) {\n  const savedCallback = useRef(callback);\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    if (delay === null) {\n      return;\n    }\n\n    const id = setInterval(() => savedCallback.current(), delay);\n\n    return () => clearInterval(id);\n  }, [delay]);\n}\n\nexport default useInterval;\n","import { atom, useSetRecoilState } from \"recoil\";\nimport { SlimeLocation } from \"./slimeLocationState\";\n\nconst slimeLocationsState = atom<SlimeLocation[]>({\n  key: \"slimeLocationsState\",\n  default: [{ id: 0, x: 0, y: 0 }]\n});\nexport default slimeLocationsState\n\nexport function useCreateLocation() {\n  const setSlimeLocationsState = useSetRecoilState(slimeLocationsState);\n  return ({ x, y }: { x: number, y: number }) => {\n    setSlimeLocationsState((slimeLocations) => {\n      return [\n        ...slimeLocations,\n        {\n          id: slimeLocations.length,\n          x,\n          y\n        }\n      ]\n    })\n  }\n}\n","import _ from \"lodash\";\nimport { selector } from \"recoil\";\nimport slimeLocationsState from \"./slimeLocationsState\";\n\nconst slimeLocationsBoundingBoxState = selector({\n  key: 'slimeLocationsXRangeState',\n  get: ({ get }) => {\n    const slimeLocations = get(slimeLocationsState);\n\n    const slimeXs = _.map(slimeLocations, 'x');\n    const slimeYs = _.map(slimeLocations, 'y');\n    const minSlimeX = _.min(slimeXs) || 0;\n    const maxSlimeX = _.max(slimeXs) || 1;\n    const minSlimeY = _.min(slimeYs) || 0;\n    const maxSlimeY = _.max(slimeYs) || 1;\n\n    return {\n      minX: minSlimeX,\n      maxX: maxSlimeX,\n      minY: minSlimeY,\n      maxY: maxSlimeY,\n    }\n  }\n});\nexport default slimeLocationsBoundingBoxState;\n","import { selector } from \"recoil\";\nimport slimeLocationsBoundingBoxState from \"./slimeLocationsBoundingBoxState\";\n\nconst mapViewBoxState = selector({\n  key: \"mapViewportState\",\n  get: ({ get }) => {\n    const { minX, maxX, minY, maxY } = get(slimeLocationsBoundingBoxState);\n    return `${minX - 1} ${minY - 1} ${maxX - minX + 2} ${maxY - minY + 2}`\n  }\n});\nexport default mapViewBoxState;\n","import _ from \"lodash\";\nimport { selector } from \"recoil\";\nimport slimeLocationsBoundingBoxState from \"./slimeLocationsBoundingBoxState\";\nimport slimeLocationsState from \"./slimeLocationsState\";\n\nexport interface Location {\n  x: number;\n  y: number;\n}\n\nfunction serializeLocation({ x, y }: Location) {\n  return `${x},${y}`\n}\n\nfunction parseLocation(serialized: string): Location {\n  const stringCoordinates = _.split(serialized, \",\");\n  return {\n    x: _.parseInt(stringCoordinates[0]),\n    y: _.parseInt(stringCoordinates[1])\n  }\n}\n\nconst potentialNextSlimeLocationsState = selector<Location[]>({\n  key: 'potentialNextSlimeLocationsState',\n  get: ({ get }) => {\n    const slimeLocations = get(slimeLocationsState);\n    const serializedSlimeLocations = new Set(_.map(slimeLocations, serializeLocation));\n    const serializedPotentialNextSlimeLocations = new Set<string>();\n\n    const potentiallyAddNextSlimeLocation = (location: Location) => {\n      const serializedLocation = serializeLocation(location);\n      if (!serializedSlimeLocations.has(serializedLocation)) {\n        serializedPotentialNextSlimeLocations.add(serializedLocation);\n      }\n    }\n\n    _.each(slimeLocations, ({ x, y }) => {\n      potentiallyAddNextSlimeLocation({ x, y: y - 1 });\n      potentiallyAddNextSlimeLocation({ x: x + 1, y: y - 1 });\n      potentiallyAddNextSlimeLocation({ x: x + 1, y });\n      potentiallyAddNextSlimeLocation({ x: x + 1, y: y - 1 });\n      potentiallyAddNextSlimeLocation({ x, y: y + 1 });\n      potentiallyAddNextSlimeLocation({ x: x - 1, y: y + 1 });\n      potentiallyAddNextSlimeLocation({ x: x - 1, y });\n      potentiallyAddNextSlimeLocation({ x: x - 1, y: y - 1 });\n    });\n\n    const {minX, minY, maxX, maxY} = get(slimeLocationsBoundingBoxState);\n    const effectiveOccupiedLocationsCount = slimeLocations.length + 1;\n    return _.sortBy(\n      _.map(Array.from(serializedPotentialNextSlimeLocations), parseLocation),\n      ({ x, y }) => {\n        const effectiveMinX = _.min([minX, x]) ?? 0;\n        const effectiveMaxX = _.max([maxX, x]) ?? 0;\n        const effectiveMinY = _.min([minY, y]) ?? 0;\n        const effectiveMaxY = _.max([maxY, y]) ?? 0;\n\n        const effectiveWidth = effectiveMaxX - effectiveMinX;\n        const effectiveHeight = effectiveMaxY - effectiveMinY;\n\n        const effectiveArea = effectiveWidth * effectiveHeight;\n        const effectiveDensity = effectiveOccupiedLocationsCount / (effectiveArea || 1);\n\n        const densityDifferenceFromTarget = effectiveDensity - 0.25;\n        const boundsRatioDifferenceFromTarget = effectiveWidth / effectiveHeight - 1;\n\n        return 0.75 * densityDifferenceFromTarget * densityDifferenceFromTarget + 0.25 * boundsRatioDifferenceFromTarget * boundsRatioDifferenceFromTarget;\n      }\n    );\n  }\n})\nexport default potentialNextSlimeLocationsState;\n","import _ from \"lodash\";\nimport { selectorFamily } from \"recoil\";\nimport slimeLocationsState from \"./slimeLocationsState\";\n\nexport interface SlimeLocation {\n  id: number;\n  x: number;\n  y: number;\n}\n\nconst DEFAULT_SLIME_LOCATION = { id: 0, x: 0, y: 0 };\n\nconst slimeLocationState = selectorFamily({\n  key: \"slimeLocationsState\",\n  get: (id: number) => ({ get }) => _.find(get(slimeLocationsState), (slimeLocation: SlimeLocation) => slimeLocation.id === id) || DEFAULT_SLIME_LOCATION\n});\nexport default slimeLocationState\n","import { useRecoilValue } from \"recoil\"\nimport slimeLocationState from \"../state/slimeLocationState\"\n\nexport default function SlimeLocation({ id }: { id: number; }) {\n  const { x, y } = useRecoilValue(slimeLocationState(id));\n  return <rect className=\"slime\" x={x} y={y} width=\"1\" height=\"1\"/>\n}\n","import _ from \"lodash\";\nimport { useCallback } from \"react\";\nimport { useRecoilValue } from \"recoil\";\nimport useInterval from \"../hooks/useInterval\";\nimport mapViewBoxState from \"../state/mapViewBoxState\";\nimport potentialNextSlimeLocationsState from \"../state/potentialNextSlimeLocationsState\";\nimport slimeLocationsState, { useCreateLocation } from \"../state/slimeLocationsState\";\nimport SlimeLocation from \"./SlimeLocation\";\n\nexport default function Map() {\n  const potentialNextSlimeLocations = useRecoilValue(potentialNextSlimeLocationsState);\n  const slimeLocations = useRecoilValue(slimeLocationsState);\n  const mapViewport = useRecoilValue(mapViewBoxState);\n  const createLocation = useCreateLocation();\n\n  const update = useCallback(() => {\n    createLocation(\n      _.sample(\n        _.slice(\n          potentialNextSlimeLocations,\n          0,\n          Math.ceil(potentialNextSlimeLocations.length * 0.25)\n        )\n      )!\n    );\n  }, [potentialNextSlimeLocations, createLocation]);\n\n  useInterval(update, 12);\n\n  return <svg className=\"map-svg\" viewBox={mapViewport}>\n    {\n      _.map(slimeLocations, ({ id }) => <SlimeLocation id={id} key={id} />)\n    }\n  </svg>\n}\n","import { RecoilRoot } from 'recoil';\nimport './App.css';\nimport Map from \"./components/Map\";\n\nfunction App() {\n  return (\n    <RecoilRoot>\n      <Map />\n    </RecoilRoot>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}